---
title: Web Audio Effect Library with Rust and WASM
date: "2025-07-15"
section: blog
tags: ["react", "web audio", "wasm", "vite", "tutorial"]
cover_image: "./image.png"
---

As I‚Äôve been working with the Web Audio API, I‚Äôve become most interested in the Web Worklet API that lets you process audio on a separate thread. This makes audio apps run meaner and leaner by moving heavier operations off the main thread, allowing you to do more (like rendering UI or handling other interactions).

One way to step this up to the next level is combining the Web Audio worklet with WASM (or WebAssembly), a way to run native languages on the web. Rather than crunching numbers with JavaScript, we can pass the data to a ‚Äúnative‚Äù layer and have a language like C++ or Rust handle it. If I told you this improves performance you‚Äôd say I was mad, but WASM actually improves performance by circumventing many of the pitfalls JavaScript comes packed in with (like garbage collection).

![A promo graphic for the Clawdio library with logo, logotype, and a subtitle reading Web Audio Worklets + Rust WASM.](image%201.png)

That‚Äôs why I made [**clawdio**](https://www.npmjs.com/package/clawdio) - a JavaScript library that lets you use Web Audio worklets that process audio using Rust (through WASM). It provides easy to use modules, like a Bitcrusher node, that adds a ‚Äúcrunchy‚Äù or ‚Äúpixelated‚Äù effect to audio. You can chain these nodes into a Web Audio context, and they‚Äôll handle the dirty work of initializing the WASM-based web worklets for you.

In this blog I‚Äôll go over the process of putting together the library, and all the challenges I tackled in the creation. From bundling Rust code to WASM, to setting up Vite properly to distribute WASM and audio workers ‚Äî we‚Äôll go over lots of great tips for creating an NPM library with web workers.

You can browse [the full source code](github.com/whoisryosuke/clawdio) for reference. And you can see the library and the Bitcrusher effect in action [in the example app](https://github.com/whoisryosuke/clawdio/tree/main/packages/examples).

> ‚ö†Ô∏è This article is the second in a series about using Rust and WASM for Web Audio. If you‚Äôre interested in learning the basics of audio worklets and how to bundle Rust code into WASM, [check out the first blog post](https://whoisryosuke.com/blog/2025/processing-web-audio-with-rust-and-wasm).

# High level architecture

Ultimately we need to ship Web Audio worklets written in JavaScript and WASM bundles to NPM. Based on [the last tutorial](https://whoisryosuke.com/blog/2025/processing-web-audio-with-rust-and-wasm), we can basically combine the two repos we created (the Rust and JS) and combine them into one. We know that we‚Äôll need a folder dedicated to our Rust project. And then the frontend JavaScript code will be a separate folder, that relies on WASM generated by the Rust project.

Here‚Äôs the top level structure of the code:

![The early directory structure of the project with top level folders called dist, modules, and src - each containing the library production bundle, Rust source code, and the library source code respectively.](image%202.png)

When we want to write **Rust** code, we‚Äôll do it inside `/modules/` folder. We‚Äôll also create a separate folder for each WASM module so we can separate each module into it‚Äôs own WASM bundle, instead of having one big one to load all the effects.

The **JavaScript** code that gets released to NPM will be kept inside a `/src/` directory (basically the default folder for a Vite project - or most JS projects). We‚Äôll have a folder dedicated to our ‚Äúworklets‚Äù or `/workers/` and another folder called `/nodes/` to contain a convenient custom Audio Node that initializes the worklet properly for the user.

When we finally build our JS library, it‚Äôll get placed inside a `/dist` folder that will be released to NPM.

> üìÅ I end up using a monorepo setup later, but this fundamental architecture doesn‚Äôt change, just moves folders if anything.

# Creating a WASM-powered library

## Project Setup

Like I mentioned before, this article is a continuation of my previous blog post, so I‚Äôll be using most of that work as the basis for this one. That means I‚Äôll be using my [rust-wasm-library-template](https://github.com/whoisryosuke/rust-wasm-library-template) to handle bundling Rust code to WASM.

> Why WASM? I‚Äôve covered this topic [in my previous article](https://whoisryosuke.com/blog/2025/processing-web-audio-with-rust-and-wasm#why-wasm), check it out for an in-depth breakdown of the benefits.

And for releasing my library to NPM, so I‚Äôll use my [react-vite-library-boilerplate](https://github.com/whoisryosuke/react-vite-library-boilerplate) to simplify bundling JS code and automating the release to NPM using GitHub Actions. You can see [a breakdown of this template here](https://whoisryosuke.com/blog/2025/releasing-a-react-library-in-2025).

I created a new folder for the project, then created a `/modules/` folder inside that, and `git clone`'d the Rust WASM library into there (without a `.git` repo inside - no need for submodules). Then I copied over the JS Vite template into the root folder.

With this setup, we have Rust code that can bundle to WASM, and a separate JS library that can release to NPM. Let‚Äôs put those together.

You can see [the commit here](https://github.com/whoisryosuke/clawdio/commit/cd5318a457b027f73b9e03c631b95758dc2fc9a9) for this initial phase.

## Building Rust modules

We have Rust modules that need to bundle into WASM and JS, and each module is it‚Äôs own dedicated Rust project. To bundle these projects, we run the `wasm-pack` CLI.

And ideally, all these modules are necessary for the JS code, so they should bundle before the JS code bundles, because the JS code will import it.

We can make a little Node script that walks through the `/modules/` folder and builds each project inside using the `wasm-pack` CLI.

```tsx
import { execFileSync } from "child_process";
import { copyFileSync, readdirSync } from "fs";
import path from "path";

/**
 * This file handles building the Rust code into WASM and JS,
 * and copies the WASM to the root asset folder (`/public`)
 * so we can distribute them with library.
 */

const log = (...props) => console.log("[CLAWDIO/BUILD]", ...props);

log("Starting build");

// 1Ô∏è‚É£ Build all WASM modules

// Get all modules
const modules = readdirSync("./modules");
log("Processing Rust modules: ", modules);

modules.forEach((moduleName) => {
  // wasm-pack build --target web
  execFileSync("wasm-pack", [
    "build",
    `./modules/${moduleName}/`,
    "--target",
    "web",
  ]);
});

log("Build completed successfully üëèüéâ");
```

Then we can add this to the root `package.json` to build Rust code using `yarn build:modules`

```tsx
"scripts": {
  "build:modules": "node scripts/build.js",
}
```

Now whenever we want to build our library, we‚Äôll run `yarn build:modules` then `yarn build`.

## Linking modules

So how does the JS code get access to the Rust code?

In the previous blog post, I cover how the `wasm-pack` library bundles the Rust code as a binary `.wasm` file, and it also outputs a nice `.js` file that initializes the WASM and exposes the module on the JS layer. This gets generated inside a `/pkg` folder inside the Rust project alongside a `package.json` so we can release it independently to NPM if we needed.

![The Rust modules directory with an example module structure with a src folder for source code and a pkg folder for bundled production code.](image%203.png)

To use the Rust code, we‚Äôll want to import the `.js` code via the auto-generated WASM `package.json` from that `/pkg` folder.

Normally I‚Äôd setup a monorepo, but NPM has recently started to support local dependencies using the `file:` syntax. Inside the root folder‚Äôs `package.json`, I added a new dependency for the Rust module and instead of using a version, I passed the path to the compiled Rust module `file:./modules/module-name/pkg/`.

```tsx
{
  "name": "clawdio",
  "dependencies": {
    "clawdio-bitcrusher": "file:./modules/bitcrusher/pkg",
```

This worked great, and let me import the WASM initialization code in my frontend JS project.

```tsx
// The Rust module (technically the `package.json` inside `/pkg` folder)
import init, { BitcrusherModule } from "clawdio-bitcrusher";

// Later in the web worklet
init();
```

### Monorepo for release though

Despite this working great for local development, this setup quickly fell apart during the release workflow. When publishing the library to NPM, I received an error that it couldn‚Äôt find the WASM dependency, and it was looking in the root of my new project folder (because of the relative `file:` path).

The solution was exactly what I was trying to avoid, a classic monorepo setup. I went with my tried and true architecture using Yarn v1‚Äôs Workspaces feature. This hoists a few folders I specify (like `/packages/` or `/modules/*/pkg` to include the WASM libraries), and lets the build system use them instead of downloading the dependency from NPM.

You can see the major shift to monorepo [in this commit](https://github.com/whoisryosuke/clawdio/commit/10c93765c1c4f89b95773c4f5ffc478effe45d65).

## Importing workers

We‚Äôre using `AudioWorkletNode`, which is a kind of [‚Äúweb worker‚Äù](https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Using_AudioWorklet) that takes code and runs it in a separate thread. When we initialize the worklet node, we need to pass a file path to this worklet/worker.

In the previous blog, I used Vite as my build system, and I was able to leverage their `?url` parameter to get a file path to the web worker. This is required for initializing Web Worklets (and Web Workers in general) - they usually take a whole JS file and then run that in their own isolated JS context. You can learn more about this process [in the Vite docs here](https://v3.vitejs.dev/guide/assets.html#explicit-url-imports).

### Missing Typescript types

I was having issues initially using the `?url` parameter, I kept getting TS errors. It seems that you need to explicitly include the Vite types into your `tsconfig.json` to inform Typescript that `import` paths might include Vite-specific parameters.

```cpp
{
  "compilerOptions": {
    "types": ["vite/client"],
```

### Exporting workers as assets

Though I was still having issues with this setup. Ideally, when the library builds, the audio worklet should become a separate JS file. This is because we need to have a path to it for our audio worklet node. It shouldn‚Äôt be embedded alongside our library code (aka one big `clawdio.es.js` file), or the audio worklet won‚Äôt be able to start correctly.

Vite supports this setup by adding the `?worker` parameter to an `import` path. This ensures the file gets bundles separately. And when we combine it with the `?url` (making it `?worker&url` - like URL params on the web) ‚Äî we‚Äôre able to get a file path to the worklet JS file in our bundle. Learn more about [using web workers in Vite here](https://v3.vitejs.dev/guide/features.html#web-workers).

```tsx
import BitcrusherWorklet from "@/workers/bitcrusher.ts?worker&url";

// Create the worklet
console.log("creating worklet...");
try {
  // Resolve the URL relative to the current module
  await audioCtx.audioWorklet.addModule(BitcrusherWorklet);
```

Cool, now the `bitcrusher.ts` file is compiled to JavaScript by Vite, and it handles all the `import` to the Rust module adding that too. If you run a build you should see a new `assets/bitcrusher.js` appear in the `/dist` folder.

### IIFE vs Module Workers

But wait, if we look at the bundled code for the worker, we can see that it‚Äôs wrapped in an IIFE function (a function that immediately runs when imported). This is because Vite expects you to initialize your worker using a `new Worker()` syntax.

```jsx
() => {
	// our worker code
	class T extends AudioWorkletProcessor {}
}();
```

We don‚Äôt want this. We just need the worker compiled separately, and as raw JS that the Audio Worklet can load as a module.

We can fix this by adding one line to our Vite config:

```jsx
export default defineConfig({
  worker: {
    format: "es",
```

Now if we check the final worker bundle the code should look normal, with our `AudioWorkletProcessor` class available at the root level of the document.

## Preventing base64 WASM

If inspect the main library‚Äôs bundle, we‚Äôll notice one key issue. Since we `import` our WASM initialization script in our worker, it appends it to the bundle. This is to be expected (and kinda what we want) - but there‚Äôs a big issue with the bundle - a literal big issue: our WASM file has been inlined as a base64 file.

```cpp
// Inside the final JS bundle in `/dist/`
// This goes on for 100+ lines, shortened for sanity
W = "data:video/mp2t;base64,
```

It basically means the entire WASM file is inside the worker file, bloating it‚Äôs file size to **25kb**:

```tsx
[vite:dts] Start generate declaration files...
dist/assets/bitcrusher-4GRzcwnf.js  25.29 kB
dist/clawdio.es.js                   8.49 kB ‚îÇ gzip: 2.98 kB
[vite:dts] Declaration files built in 425ms.
```

Why does this happen? This is a pretty simple problem that took me a while to pin down.

To understand why this is happening, let‚Äôs take a look back at the WASM initialization code generated by `wasm-pack`. When we `init()` our module, the first function parameter is the WASM module. But this could be many things ‚Äî in our case it might by the buffer that makes up the WASM code, or maybe a path to the WASM that needs to be fetched.

The `init()` function checks if you passed a module, and if it doesn‚Äôt detect a module or path, it provides a default module. It fetches the module using a `new URL()` to define the path to it, then fetches that URL. Our problem lies here, with the `new URL()` statement:

```tsx
if (typeof module_or_path === "undefined") {
  module_or_path = new URL("clawdio_bitcrusher_bg.wasm", import.meta.url);
}
```

Vite has a built-in feature that takes any instance of `new URL()` in your code and attempts to inline it inside your bundle. You can see [the docs for that here](https://v3.vitejs.dev/guide/assets.html#new-url-url-import-meta-url).

So we have a problem here. `wasm-pack` automatically generates this `init()` script for each module. In order to fix the problem for Vite, we‚Äôd need to alter the `URL` to use non-static path. But we can‚Äôt easily modify the WASM library code after generated (we could append our build script to do some find/replace logic‚Ä¶but there should be more efficient ways to handle it).

What if we initialized the WASM module ourselves? We could try, but there‚Äôs a special step for WASM initialization that handles reserving the memory for the module, and this function is conveniently provided by `wasm-pack` for us. So we‚Äôre kind of forced to use this setup.

What if we changed the way Vite interpreted the file?

### Custom Vite plugin

How do we prevent Vite from inlining a `URL`? Apparently there‚Äôs no easy configuration for it, so we‚Äôll have to create a custom plugin that checks if the code contains a `URL` and then removes the `URL` replaces it with a `false` boolean statement.

```tsx
// When we import WASM in worker, wasm-pack creates an initialization wrapper using `new URL`.
// Vite transforms any `new URL()` and generates base64 - @see: https://vite.dev/guide/assets.html#new-url-url-import-meta-url
// That increases bundle by doubling up WASM (once as `.wasm` and another as base64)
// This prevents that by finding any instances and removing them.
const preserveUrlPlugin = {
  name: "worker-preserve-url",
  transform(code) {
    if (code.includes("new URL(")) {
      const searchTerm = /new URL\([^)]*\)/g;
      const newCode = code.replace(searchTerm, "false");
      return {
        code: newCode,
        map: null,
      };
    }
  },
};

export default preserveUrlPlugin;
```

We use this plugin by placing it inside the `workers.plugins` section of the Vite config. This was another area that I got blocked on for a bit. If you add this to the regular `plugins` array, it won‚Äôt run on any file you add `?worker` to. This is a great way to ensure workers don‚Äôt have unnecessary plugins run (like React, since our workers are written in vanilla JS).

```tsx

// https://vitejs.dev/config/
export default defineConfig({
  base: "./",
  plugins: [
    react(),
    dts({
      rollupTypes: true, // Bundles all types into a single file
    }),
    tsconfigPaths(),
  ],

  // Plugins that only run on workers
  worker: {
    plugins: () => [preserveUrlPlugin],
  },
```

If you ever need to debug this sort of situation, I found it was useful to just log out the `id` that Vite provides. That returns the filename, so you can see if it‚Äôs running the plugin on the right file. In my case, the worker didn‚Äôt pop up until I threw the plugin in the worker plugins property.

```tsx
export default {
  plugins: [
    {
      name: "debug-transform",
      transform(code, id) {
        console.log("Transform ID:", id);
        // Look for your third-party module in the logs
        if (code.includes("new URL(")) {
          console.log("Found new URL() in:", id);
        }
        return null;
      },
    },
  ],
};
```

Cool, now if we inspect our bundle, we shouldn‚Äôt see our WASM embedded inside our worklet. It should be 4kb instead of 25kb.

```tsx
[vite:dts] Start generate declaration files...
dist/assets/bitcrusher-CIHdRKFA.js  4.05 kB
dist/clawdio.es.js                  8.49 kB ‚îÇ gzip: 2.98 kB
```

## Bundling WASM

One last thing that I didn‚Äôt notice until I tried to `import` this library in a new project ‚Äî the WASM isn‚Äôt included in the bundle. If we build the library now, there‚Äôs no WASM inside the `/dist/` folder.

And currently, we have a custom audio node that fetches that WASM bundle. But without it inside the final bundle, it has nothing to `fetch`.

So how do we handle this? It‚Äôs actually rather simple with Vite. We already import the WASM as a path, we just need to actually `import` the WASM module itself.

```

import "clawdio-bitcrusher/clawdio_bitcrusher_bg.wasm?no-inline";
import BitcrusherWasmPath from "clawdio-bitcrusher/clawdio_bitcrusher_bg.wasm?url&no-inline";
```

This should look similar to when you import other static assets in Vite, like CSS or images. Though note how we use `?no-inline` for the WASM. This ensures it doesn‚Äôt get encoded into base64 and embedded in the current JS file.

But we have one last problem. By default, Vite doesn‚Äôt include `.wasm` files in the final bundle (aka `/dist/` folder). We can enable that with a quick flag in the Vite config though:

```tsx
export default defineConfig({
  // Make sure to include `.wasm` files
  assetsInclude: ["**/*.wasm"],
```

You can learn more about the `assetsInclude` property [in the Vite docs](https://vite.dev/config/shared-options.html#assetsinclude), and [here‚Äôs a list of supported modules](https://github.com/vitejs/vite/blob/main/packages/vite/src/node/constants.ts#L123-L163) (which doesn‚Äôt include WASM).

# Audio node wrapper

In order to release this in a library, we need to have a way to create the `AudioWorkletNode` - as well as do the dirty business of fetching and initializing the WASM.

And since we‚Äôre using a worklet/worker, we can‚Äôt directly mutate properties on the node like we would with say a `GainNode` (e.g. `gainNode.gain.value = 0.5`). Instead we need to send messages to the worker with the data we want to update. But we can‚Äôt expect the user to handle this, because sending a message requires providing the right `type` of message - which they shouldn‚Äôt be required to know. Learn more about this process [in my previous blog](https://whoisryosuke.com/blog/2025/processing-web-audio-with-rust-and-wasm#the-correct-way).

Instead, we‚Äôll make a function called `createBitcrusherNode` that creates the node and returns it, but also provides the helper functions we need (like `setBits` to set the ‚Äúbits‚Äù of the calculation).

```tsx
/**
 * Creates a Bitcrusher audio worklet node and initializes it's WASM module.
 * Returns the AudioWorkletNode and helpful setter functions for parameters
 * @returns BitcrusherNode
 */
const createBitcrusherNode = async (
  audioCtx: AudioContext,
  bits = 4,
  normfreq = 0.1
) => {
  // This will be the "final" node that we create
  let nodeRef: AudioWorkletNode | null = null;

  // Handle any messages from the worker. We'll init here.
  const handleNodeMessage = (e: MessageEvent) => {
    // I cut this out - but this is same process as previous WASM blog
  };

  // Here we actually create the node and fetch the WASM
  const createNode = async () => {
    // Fetch the WASM module
    const response = await fetch(BitcrusherWasmPath);
    const wasmData = await response.arrayBuffer();

    // Create the worklet
    console.log("creating worklet...");
    try {
      // Resolve the URL relative to the current module
      await audioCtx.audioWorklet.addModule(BitcrusherWorklet);
      nodeRef = new AudioWorkletNode(audioCtx, "bitcrusher");

      // Send the WASM payload to Audio processor
      nodeRef.port.postMessage({ type: "init-wasm", data: wasmData });
      // Get messages from the worklet/processor
      nodeRef.port.onmessage = handleNodeMessage;

      // Set initial values
      setNormfreq(normfreq);

      console.log("created worklet node", nodeRef);

      nodeRef.addEventListener("processorerror", (e) =>
        console.error("Audio Worklet processing error", e)
      );
    } catch (e) {
      console.log("failed to create worklet", e);
    }
  };

  // Setter functions to communicate with worklet params
  const setBits = (newBits: number) => {
    if (!nodeRef) return;
    nodeRef.port.postMessage({ type: "set-bits", data: newBits });
  };

  // Create the node and return it
  await createNode();

  if (!nodeRef) {
    throw "Couldn't create node, try again";
  }

  return {
    node: nodeRef,
    setBits,
    setNormfreq,
  } as BitcrusherNode;
};
```

The function essentially runs the `createNode()` function, which creates the node. Then we just return that to the user in an object, along with our helper functions.

Using it looks like this:

```tsx
const bitcrusher = await createBitcrusherNode();
console.log("The node", bitcrusher.node);
```

It‚Äôs a little tricky at first for the user, since most audio nodes are created and self contained. But this isn‚Äôt a completely foreign pattern.

> This pattern is somewhat inspired by [the custom audio node architecture](https://web.dev/case-studies/jamwithchrome-audio#writing_custom_audio_effects) Google used for their JAM with Chrome project. They wrap a few audio nodes together in a ‚Äúcustom node‚Äù and expose necessary APIs to the user through parameters.

To make things easier for the user, I also made a custom type to package thing up. It also extends a base type, allowing us to create more types for other nodes:

```tsx
export type CustomAudioWorkletNode = {
  node: AudioWorkletNode;
};

export type BitcrusherNode = CustomAudioWorkletNode & {
  setBits: (newBits: number) => void;
  setNormfreq: (newFreq: number) => void;
};
```

This way we return the `BitcrusherNode` type to the user, and their IDE will be able to autocomplete and whatnot and let them know it‚Äôs not an `AudioWorkletNode` itself ‚Äî but it contains one.

And with that, we have:

- Rust code compiled to WASM (with JS ‚Äúglue‚Äù code) ‚Äî `/modules/bitcrusher/`
- An audio worklet that initializes the WASM and uses it ‚Äî `/src/worklet/bitcrusher.ts`
- A handy function that handles fetching the WASM and creating an audio worklet node using our custom processor ‚Äî `/src/nodes/BitcrusherNode.ts`

And we ultimately export the `BitcrusherNode` to NPM, allowing others to use it (and the underlying pre-packaged worklet + WASM).

Let‚Äôs test that out by making an example website and install the package there.

# Creating an example site

In order to quickly test the library, and provide some audible and visual output for the modules, I created an example app inside the project under the `/examples/` folder.

It‚Äôs another Vite project with React installed, and it uses the local `file:` linking to pickup the `package.json` of the NPM library. This lets me test the library as a library ‚Äî instead of using the Vite application embedded inside the library (via `src/App.tsx`).

### One more worker bug

But when I imported my `BitcrusherNode` from the library, I got an error that the worklet isn‚Äôt found. If we check the library bundle, we can see the worker there in the `/dist/assets/` folder. So why isn‚Äôt it getting picked up?

My example website is trying to load the worklet from a relative URL, so it tries loading the worker from the `/example/public/` folder (which Vite serves it‚Äôs assets from). But the worker isn‚Äôt there, it‚Äôs in my `node_modules` folder (and technically symlinked to another spot).

So how do ensure that the worker is loaded from the correct place by apps that consume our library?

We need to add the `base` property to the library‚Äôs Vite config. This has Vite load assets using `new URL` with the `import.meta` setting ‚Äî meaning the consuming app will know to check relatively for it (inside `node_modules`).

```tsx
export default defineConfig({
  base: "./",
```

Once we add this and re-run the library‚Äôs `build`, we can see that the worker is fetched correctly in our example app. And if you inspect the library code, you should see a `new URL` in there now pointing to the worker.

```tsx
const u = "" + new URL("assets/bitcrusher-CIHdRKFA.js", import.meta.url).href;
```

### Filesystem security bug

Except it‚Äôs not fetching correctly. If you‚Äôre using the same `file:` setup as me for linking to the module, this is going to cause issues with Vite‚Äôs security. Vite doesn‚Äôt load files outside of it‚Äôs context (aka the ‚Äúworkspace root‚Äù or same folder it‚Äôs inside of). And for our example app (that bundles with Vite), it‚Äôs trying to access our library code from the folder above it.

You can see this in the error, we try and load from the `localhost` using the `@fs` path, which then targets a specific folder - in our case the parent library code.

```tsx
GET
http://localhost:5173/@fs/E:/Development/React/clawdio/dist/assets/bitcrusher-CIHdRKFA.js
[HTTP/1.1 403 Forbidden 4ms]
```

We can fix this by enabling the parent folder explicitly in the Vite config under the `server.fs` property. You can see [the docs on that here](https://vite.dev/config/server-options.html#server-fs-strict).

```tsx

export default defineConfig({
  plugins: [react(), tsconfigPaths()],
  server: {
    fs: {
      // Allow serving files from one level up from the project root
      allow: ["..", "./node_modules"],
    },
  },
```

> üìÅ Only users who work with the library in development should have to deal with this workaround. If you‚Äôre consuming from `npm` or `yarn` ‚Äî it should pick up the library fine.

### Using the module in React

And with that the module was working in the example Vite app. Here‚Äôs how it‚Äôd look:

```tsx
import { useCallback, useEffect, useRef } from "react";
import useAudioStore from "@/store/audio";
import { createBitcrusherNode } from "clawdio";
import type { BitcrusherNode } from "clawdio";

type Props = {
  bits?: number;
  normfreq?: number;
};

const Bitcrusher = ({ bits = 4, normfreq = 0.1 }: Props) => {
  const nodeRef = useRef<BitcrusherNode | null>(null);
  const { audioCtx, addAudioNode, removeAudioNode } = useAudioStore();

  const createNode = useCallback(async () => {
    nodeRef.current = await createBitcrusherNode(audioCtx, 4, 0.1);

    addAudioNode("bitcrusher", nodeRef.current.node);
  }, [addAudioNode, audioCtx]);

  useEffect(() => {
    if (!audioCtx || nodeRef.current) return;
    createNode();

    return () => {
      if (nodeRef.current) removeAudioNode("bitcrusher");
      nodeRef.current?.node.disconnect();
    };
  }, [audioCtx, createNode, removeAudioNode]);

  useEffect(() => {
    nodeRef.current?.setBits(bits);
  }, [bits]);

  useEffect(() => {
    nodeRef.current?.setNormfreq(normfreq);
  }, [normfreq]);

  return <></>;
};

export default Bitcrusher;
```

We import our `createBitcrusherNode` function and pass it the audio context, as well as a couple of parameters, to create a new `BitcrusherNode`. We `await` for it because it has to `fetch` the WASM bundle and initialize it. Then we add the node to our store, which handles the process of ‚Äúchaining‚Äù it to the output (aka your speakers).

To be able to experience the node in action, we need to have audio playing. Normally for testing, we‚Äôd use a simple sine wave oscillator to get consistent results. But for fun, let‚Äôs use a sampler with that will play an `.mp3` file.

The sampler has buttons for each piano key, and plays the audio sample when button is pressed. It re-pitches the sample depending on the note played as well (so higher pitch notes sound actually higher).

When we play the sample, we loop through all the audio nodes in the store and chain them after the sample. This chains in our `BitcrusherNode`, as well as other useful nodes like an `AnalyserNode` we use to draw a waveform in our `<Waveform />` component.

> There‚Äôs a bit going on in the example app I won‚Äôt cover here, but I might cover it in a future blog post dedicated to the topic of web audio.

When we load up the app is should look like this:

![A web browser loading a local web app. 2 canvases are side by side horizontally, with the left showing the audio waveform in full, and the right showing a live waveform that‚Äôs currently flat. Below are buttons for each piano key from the 3rd to 5th octave.](image%204.png)

And specifically, if we play the audio, it should sound ‚Äúcrunchy‚Äù or lower quality from the `BitcrusherNode`. You can test if it works by removing the `<Bitcrusher />` component from the React render tree and playing the sound again. It should sound ‚Äúcleaner‚Äù, or unfiltered.

This was spread across a few commit, but [the latest one is here](https://github.com/whoisryosuke/clawdio/commit/29822e45e6cbd64bc3ed74b05e0eb0769ee740e7) for testing.

# Releasing to NPM

We‚Äôve got a library, it probably works because we tested it in an example app, so let‚Äôs release it to NPM finally. We could just run the build process and then `npm publish` - but that‚Äôs too manual. We‚Äôd also have to handle bumping our version each time, and also hope that it build properly on our machine (and something like Windows doesn‚Äôt mess it up).

Instead, let‚Äôs use a continuous integration and deployment (or CI/CD) workflow by leveraging GitHub Actions. Most of this setup comes [from my Vite library template](https://github.com/whoisryosuke/react-vite-library-boilerplate/tree/main/.github/workflows), but it required slight modification to get the Rust WASM code compiled.

```yaml
name: Publish package on NPM

on:
  release:
    types: [created]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: 22.12.0
          registry-url: https://registry.npmjs.org/
      - uses: jetli/wasm-pack-action@v0.4.0
      - run: yarn build:modules
      - run: yarn
      - run: yarn build
      - run: npm publish
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
```

This workflow does a few things:

1. Checks out the Git repo to access the files
2. Sets up NodeJS on the exact version we need (some dependencies require v22+)
3. Installs the `wasm-pack` CLI so we can use it for building Rust code (shoutout to jetli for their convenient package).
4. Then we do exactly that and build Rust code with it using the custom script we wrote earlier `yarn build:modules`
5. Then we build the library code
6. And finally we release the code to NPM

The release process itself is pretty easy. We write code, hopefully make sure it works (no testing libraries‚Ä¶yet‚Ä¶), and then push the code to GitHub on the `main` branch when it‚Äôs ready.

Then we can trigger a build by activating the ‚Äúgenerate version tag‚Äù workflow, which bumps the version in the library‚Äôs `package.json` for us and creates a tag on GitHub for it. Then we can create a new release in the GitHub UI (or CLI if you want), which triggers the NPM release workflow.

And with that, we have a library on NPM: [**clawdio**](https://www.npmjs.com/package/clawdio).

## But what about the Rust WASM?

Since our library code uses it as a dependency, and it‚Äôs in a monorepo, the build system doesn‚Äôt need the code released to NPM.

But what if someone wants to use one of these modules separately for whatever reason?

Let‚Äôs release each Rust WASM module to NPM, since they‚Äôre all setup for it anyway.

Here‚Äôs what the release script looks like:

```jsx
import { execFileSync } from "child_process";
import { readdirSync } from "fs";
import path from "path";
import { fileURLToPath } from "url";

const log = (...props) => console.log("[CLAWDIO/RELEASE]", ...props);

// Get all modules
const modules = readdirSync("./modules");
log("Processing Rust modules: ", modules);

function releaseModules() {
  log("Starting release process üöÄ");

  modules.forEach((moduleName) => {
    // Get current directory equivalent for ES modules
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = path.dirname(__filename);

    // Build the path from scripts/ to modules/
    const modulePath = path.resolve(
      __dirname,
      "..",
      "modules",
      moduleName,
      "pkg"
    );
    // const modulePath = `./modules/${moduleName}/pkg`;
    log("Trying to release module", moduleName, modulePath);

    try {
      execFileSync(
        "npm",
        ["publish", "--registry", "https://registry.npmjs.org/"],
        {
          cwd: modulePath,
          stdio: "inherit", // show output in console
          env: {
            ...process.env,
            NODE_AUTH_TOKEN: process.env.NODE_AUTH_TOKEN,
          },
        }
      );
      log("Successfully released module", moduleName);
    } catch (e) {
      log("Failed to release module", moduleName);
    }
  });
}

releaseModules();
```

We basically do the same as our build modules script, where we go into `/modules/` folder and find all the folders inside (like our `bitcrusher` one).

Then we run `npm publish` in the `/pkg` directory that gets generated by `wasm-pack`. And the key here ‚Äî we pass an environment variable to our script with our NPM token. We set this in the GitHub repo settings.

I added this script to the `package.json` as `release:modules`.

Then I had to modify the GitHub action for the release workflow.

```jsx
name: Publish package on NPM

on:
  release:
    types: [created]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: 22.12.0
          registry-url: https://registry.npmjs.org/
      - uses: jetli/wasm-pack-action@v0.4.0
      - run: yarn build:modules
      - run: yarn
      - run: yarn publish:modules
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
      - run: yarn build:library
      - run: npm publish
        working-directory: ./packages/clawdio
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}

```

The key changes here:

- I added `registry-url` to the Node setup that points to the NPM registry specifically. If you don‚Äôt do this, `yarn` will try to add the module to it‚Äôs own registry (which requires it‚Äôs own auth token).
- At first I had the release logic happening in `build:modules` ‚Äî but it kept failing. It seems that in order to release, you need to run the initial `yarn`, which generates a `.npmrc` and sets up configs like registry. So the release got separated into it‚Äôs own script, and run after `yarn`.
- We also pass the NPM token to our release script, same as our final `npm publish` step.

And now when we release our library, we‚Äôll also release each Rust WASM module as a NPM module.

You can see this live with the [clawdio-bitcrusher](https://www.npmjs.com/package/clawdio-bitcrusher) module.

# How do I use it?

This should work in any JavaScript project that supports ES modules. I used React in my example app, but I designed this library to be framework agnostic, so feel free to use it directly with vanilla JS - or maybe a framework like Vue.

You should be able to install it via NPM:

```bash
# With NPM
npm install clawdio

# With Yarn
yarn add clawdio
```

Then you can import the `createBitcrusherNode` function into your app, create the node, and chain it like you would any other node (kinda):

```tsx
import { createBitcrusherNode } from "clawdio";

async function startAudio() {
  const context = new AudioContext();
  const oscillatorNode = context.createOscillator();
  const bitcrusher = await createBitcrusherNode(audioCtx, 4, 0.1);
  oscillatorNode.connect(bitcrusher.node);
  bitcrusher.node.connect(context.destination);

  oscillatorNode.start();
}

startAudio();
```

You should be able to hear the difference once you connect the node.

# Branding

Since I‚Äôm looking to develop on this library a bit, I designed branding for it, complete with it‚Äôs own custom logo.

![Figma open with a few Frames containing the Clawdio library logo and logotype alonside eachother in black and white text variants.](Screenshot_2025-07-03_232158.png)

The logo came together pretty quickly. I knew I wanted to pay homage to the Rust side of the library by featuring the library‚Äôs official mascot - the crab. And the audio portion of the library needed to be clearly conveyed.

I settled on the visual of a cartoonish crab claw, as it was easily recognizable as a crab, and scaled well to an icon. After sketching a bit with the claw, I used a classic sine waveform to shape the top claw, creating the distinctive symbol of audio.

![Figma with various text layers spread across canvas in a grid with the word clawdio in different fonts.](image%205.png)

For font family I went through several options. I initially leaned serif and rounded shapes ‚Äî but I eventually moved towards a futuristic look. It seemed more fitting since it was a cutting edge library using WASM, not something that needed to feel old.

I placed the logotype alongside the logo and tested each out, seeing which worked best to match the style of the logo. At first I leaned a little cartoony with bolder, thicker fonts, but I came back to that futuristic look after finding an aptly named ‚ÄúAudiowide‚Äù font.

![The clawdio logo in red alongside the logotype in white.](image%206.png)

I‚Äôm actually really pleased with this branding for being put together in an afternoon.

# What‚Äôs next?

The goal of this library is to optimize the processing of audio on the web using WASM. The Audio Worklet API is new, and it serves to replace the older and deprecated [createScriptProcessor API](https://developer.mozilla.org/en-US/docs/Web/API/BaseAudioContext/createScriptProcessor). That API was used to process audio data on the CPU side, which blocks the main thread and can make things like UI less responsive.

Instead, we can leverage the audio worklets to process the audio in a separate thread (and ideally using WASM).

I‚Äôll be starting by converting a few basic audio effects to worklets and use Rust where possible. The Bitcrusher was the first effect, but expect to see things like [LFO](https://github.com/Theodeus/tuna/blob/master/tuna.js#L2142-L2149), [Envelope Follower](https://github.com/Theodeus/tuna/blob/master/tuna.js#L2000-L2005), or [Moog filter](https://github.com/Theodeus/tuna/blob/master/tuna.js#L1092-L1100). You could even replicate native nodes like the `DelayNode` to create echoes, or play audio in reverse. Any effect that could be created using the `createScriptProcessor` API can be replicated as a worklet, so I‚Äôm on the hunt (and getting creative) to discover more.

![A web app rendering a node graph with web audio components. An oscillator node is chained to a bitcrusher node and analyser node. And the bitcrusher is connected to an analyser as well, to compare both signals. The bitcrushed signal has ‚Äústeps‚Äù in the line.](Screenshot_2025-07-11_232810.png)

You can see this library in action in my [web audio node graph project](https://github.com/whoisryosuke/web-audio-node-graph) where you can create a Bitcrusher node to chain into other nodes. It‚Äôs great for testing the library, but also a fantastic learning and teaching tool for visualizing the effects on the audio signal. For example, in the image above, you can more clearly see how the bitcrusher node is altering the oscillator signal by seeing the original and altered signals side by side.

<BlueskyEmbed id="3lv6znoqj2o2p" />

# Make audio with claws

I hope you consider using [**clawdio**](https://github.com/whoisryosuke/clawdio) for your next Web Audio project when you‚Äôre reaching for some cool effects. We currently only have the Bitcrusher node, but now that I have the build system ironed out ‚Äî I have a few more I‚Äôm nearly ready to release.

Or you could use the library as a basis for another Rust WASM based project so you can avoid most (if not all) of the build setup.

And even if you don‚Äôt use it, I hope this article was enlightening on the process of using workers and Vite, and releasing a library with them. There was a lot to unpack with this process, so I appreciate you if you stuck along for the wild ride.

As always, if you found this interesting or have any questions, feel free to reach out on [socials](https://bsky.app/profile/whoisryosuke.bsky.social) and [let me know.](https://mastodon.gamedev.place/@whoisryosuke)

Stay curious,<br />
Ryo
